def can_make_word(word, blocks):
    word = word.upper() # Преобразуем слово в верхний регистр, чтобы сделать функцию нечувствительной к регистру
    used_blocks = [] # Создаем список для отслеживания использованных блоков
    for letter in word: # Для каждой буквы в слове
        found = False # Флаг для отслеживания того, найдена ли буква в блоках
        for i, block in enumerate(blocks): # Перебираем все блоки
            if letter in block and i not in used_blocks: # Если буква есть в блоке и этот блок еще не использовался
                found = True # Устанавливаем флаг в True
                used_blocks.append(i) # Добавляем индекс блока в список использованных блоков
                break # Выходим из цикла
        if not found: # Если буква не найдена в блоках
            return False # Возвращаем False, потому что слово нельзя составить из заданных блоков
    return True # Если все буквы найдены в блоках, возвращаем True

blocks = [('B', 'O'), ('X', 'K'), ('D', 'Q'), ('C', 'P'), ('N', 'A'),
          ('G', 'T'), ('R', 'E'), ('T', 'G'), ('Q', 'D'), ('F', 'S'),
          ('J', 'W'), ('H', 'U'), ('V', 'I'), ('A', 'N'), ('O', 'B'),
          ('E', 'R'), ('F', 'S'), ('L', 'Y'), ('P', 'C'), ('Z', 'M')]
while True:
    word = input('Enter a word (or 0 to exit): ') # Получаем слово, введенное пользователем с клавиатуры
    if word == '0': # Если пользователь ввел 0
        break # Выходим из цикла
    print(can_make_word(word, blocks)) # Передаем это слово и список блоков в функцию can_make_word и выводим результат
